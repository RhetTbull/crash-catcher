{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Crash Catcher's Documentation","text":"<p>Crash Catcher is a decorator to catch exceptions in a python function and log them to a file. Supports optional callbacks to perform cleanup operations before the crash log is written.</p>"},{"location":"#source-code","title":"Source Code","text":"<p>The source code for this project is available on GitHub.</p>"},{"location":"#installation","title":"Installation","text":"<p>or via pip:</p> <pre><code>    python3 -m pip install crash-catcher \n</code></pre>"},{"location":"#license","title":"License","text":"<p>Crash Catcher is published under the MIT license, Copyright (c) 2023, Rhet Turnbull.</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#crash-catcher","title":"Crash Catcher","text":"<p>Error logger/crash reporter decorator</p>"},{"location":"reference/#crash_catcher.crash_catcher.crash_catcher","title":"<code>crash_catcher(filename, message, title, postamble=None, overwrite=True, **extra)</code>","text":"<p>Catch crash (uncaught exception) and create a crash dump file on error named filename</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str | Path | PathLike</code> <p>name of crash dump file to create</p> required <code>message</code> <code>str</code> <p>message to print to stderr upon crash</p> required <code>title</code> <code>str</code> <p>title to print to start of crash dump file</p> required <code>postamble</code> <code>str | None</code> <p>optional message printed to stderr after crash dump file is created.</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>if True, overwrite existing file, otherwise increment filename until a non-existent filename is found</p> <code>True</code> <code>extra</code> <code>Any</code> <p>If kwargs provided, any additional arguments to the function will be printed to the crash file.</p> <code>{}</code> This decorator should be applied to the main function of the program. <p>The message, title, and postamble arguments may include the template {filename} which will be replaced with the actual filename of the crash log. For example, if overwrite=False and the crash file <code>crash_catcher.log</code> already exists, the filename will be incremented to <code>crash_catcher (1).log</code>, <code>crash_catcher (2).log</code>, and so on until a non-existent filename is found. This filename will be used to render the {filename} template.</p> Source code in <code>crash_catcher/crash_catcher.py</code> <pre><code>def crash_catcher(\n    filename: str | pathlib.Path | os.PathLike,\n    message: str,\n    title: str,\n    postamble: str | None = None,\n    overwrite: bool = True,\n    **extra: Any,\n):\n    \"\"\"Catch crash (uncaught exception) and create a crash dump file on error named filename\n\n    Args:\n        filename: name of crash dump file to create\n        message: message to print to stderr upon crash\n        title: title to print to start of crash dump file\n        postamble: optional message printed to stderr after crash dump file is created.\n        overwrite: if True, overwrite existing file, otherwise increment filename until a non-existent filename is found\n        extra: If kwargs provided, any additional arguments to the function will be printed to the crash file.\n\n    Note: This decorator should be applied to the main function of the program.\n        The message, title, and postamble arguments may include the template {filename} which\n        will be replaced with the actual filename of the crash log. For example, if overwrite=False\n        and the crash file `crash_catcher.log` already exists, the filename will be incremented to\n        `crash_catcher (1).log`, `crash_catcher (2).log`, and so on until a non-existent filename is found.\n        This filename will be used to render the {filename} template.\n    \"\"\"\n\n    filename = (\n        pathlib.Path(filename) if not isinstance(filename, pathlib.Path) else filename\n    )\n    filename = filename.resolve()\n\n    class Default(dict):\n        def __missing__(self, key):\n            return key\n\n    def decorated(func):\n        @functools.wraps(func)\n        def wrapped(*args, **kwargs):\n            nonlocal filename, message, title, postamble\n            caller = sys._getframe().f_back.f_code.co_name\n            name = func.__name__\n            timestamp = datetime.datetime.now().isoformat()\n            start_t = time.perf_counter()\n            try:\n                return func(*args, **kwargs)\n            except Exception as e:\n                stop_t = time.perf_counter()\n\n                # if filename needs to be incremented, do so now\n                # then update message, title, and postamble {filename} template\n                if filename.exists() and not overwrite:\n                    filename = _increment_filename(filename)\n                message = message.format_map(Default(filename=filename))\n                title = title.format_map(Default(filename=filename))\n                postamble = (\n                    postamble.format_map(Default(filename=filename))\n                    if postamble\n                    else \"\"\n                )\n\n                print(message, file=sys.stderr)\n                print(f\"{e}\", file=sys.stderr)\n\n                # handle any callbacks\n                for f, msg in _global_callbacks.values():\n                    if msg:\n                        print(msg)\n                    f()\n\n                with open(filename, \"w\") as f:\n                    f.write(f\"{title}\\n\")\n                    f.write(f\"Created: {datetime.datetime.now()}\\n\")\n                    f.write(\"\\nSYSTEM INFO:\\n\")\n                    f.write(f\"Platform: {platform.platform()}\\n\")\n                    f.write(f\"Python: {pathlib.Path(sys.executable).resolve()}\\n\")\n                    f.write(f\"Python version: {sys.version}\\n\")\n                    f.write(f\"Python path: {sys.path}\\n\")\n                    f.write(f\"sys.argv: {sys.argv}\\n\")\n                    f.write(\"\\nCRASH DATA:\\n\")\n                    f.write(\n                        f\"{name} called by {caller} at {timestamp} crashed after {stop_t-start_t} seconds\\n\"\n                    )\n                    f.write(f\"{args=}\\n\")\n                    f.write(f\"{kwargs=}\\n\")\n                    for k, v in _global_crash_data.items():\n                        f.write(f\"{k}: {v}\\n\")\n                    for arg, value in extra.items():\n                        f.write(f\"{arg}: {value}\\n\")\n                    f.write(f\"Error: {e}\\n\")\n                    traceback.print_exc(file=f)\n                print(f\"Crash log written to '{filename}'\", file=sys.stderr)\n                print(f\"{postamble}\", file=sys.stderr)\n                sys.exit(1)\n\n        return wrapped\n\n    return decorated\n</code></pre>"},{"location":"reference/#crash_catcher.crash_catcher.register_crash_callback","title":"<code>register_crash_callback(func, message=None)</code>","text":"<p>Register callback to be run if crash is caught.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[], None]</code> <p>callable that will be called (with no args) by crash_catcher</p> required <code>message</code> <code>str | None</code> <p>optional message</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>id for callback which may be used with unregister_crash_callback() to remove the callback.</p> Multiple callabacks may be registered by calling this function repeatedly. <p>Callbacks will be executed in order they are registered.</p> Source code in <code>crash_catcher/crash_catcher.py</code> <pre><code>def register_crash_callback(\n    func: Callable[[], None], message: str | None = None\n) -&gt; int:\n    \"\"\"Register callback to be run if crash is caught.\n\n    Args:\n        func: callable that will be called (with no args) by crash_catcher\n        message: optional message\n\n    Returns:\n        id for callback which may be used with unregister_crash_callback() to remove the callback.\n\n    Note: Multiple callabacks may be registered by calling this function repeatedly.\n        Callbacks will be executed in order they are registered.\n    \"\"\"\n\n    callback_id = time.monotonic_ns()\n    _global_callbacks[callback_id] = (func, message)\n    return callback_id\n</code></pre>"},{"location":"reference/#crash_catcher.crash_catcher.set_crash_data","title":"<code>set_crash_data(key_, data)</code>","text":"<p>Set data to be printed in crash log</p> Source code in <code>crash_catcher/crash_catcher.py</code> <pre><code>def set_crash_data(key_: Any, data: Any):\n    \"\"\"Set data to be printed in crash log\"\"\"\n    _global_crash_data[key_] = data\n</code></pre>"},{"location":"reference/#crash_catcher.crash_catcher.unregister_crash_callback","title":"<code>unregister_crash_callback(callback_id)</code>","text":"<p>Unregister a crash callback previously registered with register_crash_callback().</p> <p>Parameters:</p> Name Type Description Default <code>callback_id</code> <code>int</code> <p>the ID of the callback to unregister as returned by register_crash_callback()</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if the callback_id is not valid</p> <p>Note: After a callback is unregisterd, it will not be called if a crash is caught.</p> Source code in <code>crash_catcher/crash_catcher.py</code> <pre><code>def unregister_crash_callback(callback_id: int):\n    \"\"\"Unregister a crash callback previously registered with register_crash_callback().\n\n    Args:\n        callback_id: the ID of the callback to unregister as returned by register_crash_callback()\n\n    Raises:\n        ValueError: if the callback_id is not valid\n\n    Note: After a callback is unregisterd, it will not be called if a crash is caught.\n    \"\"\"\n    try:\n        del _global_callbacks[callback_id]\n    except KeyError:\n        raise ValueError(f\"Invalid callback_id: {callback_id}\")\n</code></pre>"}]}